# Webpack5 的模块聚合

个人觉得，更像是参考了以前学的 java 微服务体系，只是维度不一样，相当于把业务服务降维到依赖群里

### 具备优势

- 良好的构建性能
- 良好的 Web 性能
- 解决依赖共享

以往我们用 dll 和 external 来解决构建性能和 web 性能等问题，但实施过程中经常存在头疼的问题：

- 需要为共享依赖部分做很多额外处理
- 无法使用按需加载（都是一次 load 出来的，管不了这个）

那 MF 就可以解决掉上面的问题

### 核心概念

- host，引用者
- remote，被引用的容器
- exposed，容器对外暴露的模块，比如有我们装了 antd 并且引用 Button 组建，antd 可作为容器，则 Button 可以作为容器对外暴露的模块
- shared，共享域的模块，比如 react，react-dom 这种

一个被引用的容器被称为 remote, 引用者被称为 host，remote 暴露模块给 host, host 则可以使用这些暴露的模块，这些模块被成为 remote 模块

容器通过异步的方式暴露模块。你将在使用容器中的模块前，请求容器加载(下载)你想要的模块。异步暴露模块将允许构建结果将不同的暴露模块和他们的依赖一起，放在不同的文件中。从而使得只有需要使用的模块会被加载，但是容器依旧将不同的模块一起打包。而且也将使用 webpack 的 chunk 机制(vendor 分割或者创建一个文件包含不同暴露模块之间的公共依赖等).这将帮助我们有效降低请求数量和下载大小，从而获得良好的 Web 性能容器的消费者(也就是应用者)需要能处理异步加载暴露模块(注: 同步 import 代码语义保持不变，但是运行时应转换为异步加载), Webpack 在这里做了特殊的处理，我们后续会解释图上还展示了共享模块的概念。 每一个部分，比如容器, 应用，都可以在共享 scope 中，添加共享模块(携带版本信息)，同时也可以从 共享 scope 中, 加载共享模块(需要执行版本检查)。 共享 scope 将会通过给每个消费者提供版本要求内的最大可用版本的方式，对共享模块进行冗余剔除。共享模块依旧异步暴露和异步加载。所以提供共享模块没有额外的下载消耗，只有需要的共享的模块将会被下载

摘自：[Module Federation in Webpack5](https://zhuanlan.zhihu.com/p/149429113)
